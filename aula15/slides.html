<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Convertendo expressões regulares em PEGs</title>
<meta name="author" content="Rodrigo Ribeiro"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/dist/reveal.css"/>

<link rel="stylesheet" href="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/dist/theme/white.css" id="theme"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1>Convertendo expressões regulares em PEGs</h1><h2>PCC102 - Teoria da computação</h2><h3> Rodrigo Ribeiro</h3>
</section>

<section>
<section id="slide-org95ae6d7">
<h2 id="org95ae6d7">Objetivos</h2>
<ul>
<li>Apresentar como RE podem ser representados usando PEGs,
resolvendo assim os problemas de ambiguidade.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org11ecc79">
<h2 id="org11ecc79">Expressões regulares</h2>
<ul>
<li>RE são amplamente utilizadas em bibliotecas de casamento de padrão em linguagens.</li>
<li>Porém, REs possuem o problema de ambiguidade&#x2026;</li>

</ul>

</section>
</section>
<section>
<section id="slide-orge3643b1">
<h2 id="orge3643b1">Expressões regulares</h2>
<ul>
<li>Como resolver o problema da ambiguidade?</li>

<li>Uma solução seria converter uma RE em uma equivalente determinística (sem ambiguidade).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org9faf5a0">
<h2 id="org9faf5a0">Expressões regulares</h2>
<ul>
<li>Porém, tornar uma RE arbitrária determínistica envolve gerar um AFD equivalente e
obter uma RE a partir deste AFD.</li>

<li>Essa alternativa tem custo computacional exponencial, no pior caso.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org31a228d">
<h2 id="org31a228d">Expressões regulares</h2>
<ul>
<li>Existe alguma alternativa melhor?</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf50afd1">
<h2 id="orgf50afd1">Expressões regulares</h2>
<ul>
<li>Seria possível converter uma RE em uma parsing expression de forma que a
expressão reconheça a mesma linguagem denotada pela RE?</li>

</ul>

</section>
</section>
<section>
<section id="slide-org2e4b258">
<h2 id="org2e4b258">Expressões regulares</h2>
<ul>
<li>Sim! Veremos como construir uma parsing expression que reconhece a mesma
linguagem de uma RE.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org232a20d">
<h2 id="org232a20d">Expressões regulares</h2>
<ul>
<li>Semântica alternativa para RE</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{}{(\lambda,s) \leadsto s} \\ \\
   \dfrac{}{(a,as)\leadsto s} \\ \\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org0c20b13">
<h2 id="org0c20b13">Expressões regulares</h2>
<ul>
<li>Semântica alternativa para RE</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,ss')\leadsto s'}{(e_1 + e_2,ss') \leadsto s'}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org4740618">
<h2 id="org4740618">Expressões regulares</h2>
<ul>
<li>Semântica alternativa para RE</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_2,ss')\leadsto s'}{(e_1 + e_2,ss') \leadsto s'}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org83d0e1f">
<h2 id="org83d0e1f">Expressões regulares</h2>
<ul>
<li>Semântica alternativa para RE</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,ss's'')\leadsto s's''\:\:\:(e_2,s's'')\leadsto s''}{(e_1\:e_2,ss's'') \leadsto s''}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orgeb030d1">
<h2 id="orgeb030d1">Expressões regulares</h2>
<ul>
<li>Semântica alternativa para RE</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{}{(e_1^*,s)\leadsto s}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orgffe8323">
<h2 id="orgffe8323">Expressões regulares</h2>
<ul>
<li>Semântica alternativa para RE</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,ss's'')\leadsto s's''\:\:\:(e_1^*,s's'')\leadsto s''}{(e_1^*,ss's'')\leadsto s''}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org23c5fb2">
<h2 id="org23c5fb2">Expressões regulares</h2>
<ul>
<li>Teorema: Para toda string \(s'\), \(s \in [\![e]\!]\) se e somente se \((e,ss')\leadsto s'\).</li>

<li>Prova: Indução sobre o par \((e,s)\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org8e43af8">
<h2 id="org8e43af8">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{}{(lambda, s) \leadsto_{G} s}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org42d5f24">
<h2 id="org42d5f24">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(G(A),s) \leadsto X}{(A, s) \leadsto_{G} X}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orged90279">
<h2 id="orged90279">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{}{(a, as) \leadsto_{G} s}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org714af46">
<h2 id="org714af46">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{a \neq b}{(a, bs) \leadsto_{G} \bot}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org8abe178">
<h2 id="org8abe178">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{a \neq b}{(a, \lambda) \leadsto_{G} \bot}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org3040645">
<h2 id="org3040645">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1, ss') \leadsto_{G} s'}{(e_1\,/\,e_2,ss')\leadsto_{G} s'}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orga0f0f59">
<h2 id="orga0f0f59">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1, ss') \leadsto_{G}\bot\:\:\:(e_2, ss') \leadsto_{G} X}{(e_1\,/\,e_2,ss')\leadsto_{G} X}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orgaeec1f6">
<h2 id="orgaeec1f6">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,s) \leadsto_{G} \bot}{(e_1^*,s)\leadsto_{G} s}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org6867790">
<h2 id="org6867790">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,ss's'') \leadsto_{G} s's''\:\:\:(e_1^*,s's'')\leadsto_{G} s''}{(e_1^*,s)\leadsto_{G} s}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org9061dc2">
<h2 id="org9061dc2">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,s) \leadsto_{G} \bot}{(!\,e_1,s)\leadsto_{G} s}
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org9b408d4">
<h2 id="org9b408d4">Parsing expressions</h2>
<ul>
<li>Semântica de parsing expressions</li>

</ul>

<div>
\begin{array}{c}
   \dfrac{(e_1,ss') \leadsto_{G} s'}{(!\,e_1,s)\leadsto_{G} \bot}
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orgf507d9b">
<h2 id="orgf507d9b">Equivalência</h2>
<ul>
<li>Dizemos que uma parsing expression \(p\) e uma expressão regular \(e\) são
equivalentes se:

<ol>
<li>Se \((p,ss')\leadsto_{G} s'\) então \((e,ss')\leadsto s'\).</li>
<li>Se \((e,ss')\leadsto s'\) então \(\neg ((p,ss') \leadsto \bot)\).</li>

</ol></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf6245c5">
<h2 id="orgf6245c5">Prefixos</h2>
<ul>
<li>Dizemos que uma expressão regular \(e\) possui a propriedade de prefixo se não
existem \(s,s',s''\) tais que \(s,s'\in [\![e]\!]\) e \(s' = ss''\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5bfe2bc">
<h2 id="org5bfe2bc">Prefixos</h2>
<ul>
<li>Se uma expressão regular \(e\) possui a propriedade de prefixo. Se \(e\) é equivalente
a parsing expression \(p\) então \(L(p) = [\![e]\!]\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgea0d576">
<h2 id="orgea0d576">Equivalência</h2>
<ul>
<li>Vamos apresentar uma função, \(\Pi\), que a partir de uma expressão regular e uma PEG \(G_k\)
equivalente a uma expressão regular \(e_k\), produz uma PEG \(G\) equivalente a \(e\,e_k\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org9a5cb53">
<h2 id="org9a5cb53">Equivalência</h2>
<ul>
<li>Logo, para obter a PEG equivalente a uma expressão regular \(e\) basta considerar como \(G_k\)
uma PEG para \(\{\lambda\}\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgc1d56f8">
<h2 id="orgc1d56f8">Equivalência</h2>
<ul>
<li>Definição da função \(\Pi\):</li>

</ul>

<div>
\begin{array}{lcl}
   \Pi(\lambda,G_{k}) & = & G_{k}\\
   \Pi(a,G_{k})       & = & (V_{k},\Sigma,R_{k},a p_{k}), \text{ em que:}\\
                      &   & G_{k} = (V_{k},\Sigma,R_{k},p_{k}) \\
   \Pi(e_{1}\,e_{2},G_{k}) & = & \Pi(e_{1},\Pi(e_2,G_{k}))\\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org3514354">
<h2 id="org3514354">Equivalência</h2>
<ul>
<li>Definição da função \(\Pi\):</li>

</ul>

<div>
\begin{array}{lcl}
   \Pi(e_{1}+e_{2},G_{k}) & = & (V_{2},\Sigma,R_{2}, p_{1}\,/\,p_{2}),\text{ em que:}\\
                          &   & \Pi(e_{1},G_{k}) = (V_{1},\Sigma,R_{1},p_{1}) \\
                          &   & \Pi(e_{2},(V_{1},\Sigma,R_{1},p_{1})) = (V_{2},\Sigma,R_{2},p_{2})\\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org2dfe043">
<h2 id="org2dfe043">Equivalência</h2>
<ul>
<li><p>
Definição da função \(\Pi\):
</p>

<div>
\begin{array}{lcl}
  \Pi(e^*,G_{k}) & = & (V_{1},\Sigma,R_{1} \cup \{A \leftarrow p_{1}\,/\,p_{k}\},A)\text{ em que:}\\
                 &   & G_{k} = (V_{k},\Sigma,R_{k},p_{k})\\
                 &   & \Pi(e,(V_{k}\cup\{A\},\Sigma,R_{k},A)) = (V_{1},\Sigma,R_{1},p_{1})\\
                 &   & A \not\in V_{k}
\end{array}

</div></li>

</ul>

</section>
</section>
<section>
<section id="slide-org935b189">
<h2 id="org935b189">Exemplo</h2>
<ul>
<li>Considere \(G_{k} = (\emptyset,\{0,1\},\emptyset,\lambda)\).</li>

<li>Considere \(e = (0 + 1)^{*}0\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-orge75a82b">
<h2 id="orge75a82b">Exemplo</h2>
<div>
\begin{array}{lc}
   \Pi((0 + 1)^{*}0, G_k) & = \\ \Pi((0+1)^{*},\Pi(0,G_{k}))
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-org1588099">
<h2 id="org1588099">Exemplo</h2>
<div>
\begin{array}{lc}
   \Pi((0 + 1)^{*}0, G_k) & = \\
   \Pi((0+1)^{*},\Pi(0,G_{k})) & = \\
\end{array}

</div>



</section>
</section>
<section>
<section id="slide-org43c56a5">
<h2 id="org43c56a5">Exemplo</h2>
<ul>
<li>Calculando \(\Pi(0,G_{k})\):</li>

</ul>

<div>
\begin{array}{lc}
  \Pi(0,G_{k}) & = \\
  G_{0} = (\emptyset,\{0,1\},\emptyset,0)\\
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orgc6f04d5">
<h2 id="orgc6f04d5">Exemplo</h2>
<div>
\begin{array}{lc}
   \Pi((0 + 1)^{*}0, G_k) & = \\
   \Pi((0+1)^{*},\Pi(0,G_{k})) & = \\
   \Pi((0+1)^{*},(\emptyset,\{0,1\},\emptyset,0)) & = \\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org583e1a1">
<h2 id="org583e1a1">Exemplo</h2>
<div>
\begin{array}{lc}
   \Pi((0 + 1)^{*}0, G_k) & = \\
   \Pi((0+1)^{*},\Pi(0,G_{k})) & = \\
   \Pi((0+1)^{*},(\emptyset,\{0,1\},\emptyset,0)) & = \\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org3de0e7d">
<h2 id="org3de0e7d">Exemplo</h2>
<ul>
<li>Calculando \(\Pi(0+1,(\{A\},\{0,1\},\emptyset,A))\)
<ul>
<li>Primeiro devemos calcular \(\Pi(0,(\{A\},\{0,1\},\emptyset,A))\)</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-orga2b3a38">
<h2 id="orga2b3a38">Exemplo</h2>
<ul>
<li>Calculando \(\Pi(0+1,(\{A\},\{0,1\},\emptyset,A))\)
<ul>
<li>Primeiro devemos calcular \(\Pi(0,(\{A\},\{0,1\},\emptyset,A))\)</li>
<li>Resultando em \(G_{1} = (\{A\},\{0,1\},\emptyset,0A)\)</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org803b428">
<h2 id="org803b428">Exemplo</h2>
<ul>
<li>Calculando \(\Pi(0+1,(\{A\},\{0,1\},\emptyset,A))\)
<ul>
<li>Devemos calcular \(\Pi(1,G_{1})\)</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org3964968">
<h2 id="org3964968">Exemplo</h2>
<ul>
<li>Calculando \(\Pi(0+1,(\{A\},\{0,1\},\emptyset,A))\)
<ul>
<li>Devemos calcular \(\Pi(1,(\{A\},\{0,1\},\emptyset,A))\)</li>
<li>Resultando em \(G_{2} = (\{A\},\{0,1\},\emptyset,1A)\)</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org41be543">
<h2 id="org41be543">Exemplo</h2>
<ul>
<li>Calculando \(\Pi(0+1,(\{A\},\{0,1\},\emptyset,A))\)
<ul>
<li>\(G_{1} = (\{A\},\{0,1\},\emptyset,0A)\)</li>
<li>\(G_{2} = (\{A\},\{0,1\},\emptyset,1A)\)</li>

</ul></li>
<li>Obtemos
\((\{A\},\{0,1\},\emptyset,0A\,/\,1A)\)</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3c043df">
<h2 id="org3c043df">Exemplo</h2>
<ul>
<li><p>
Obtemos a PEG para \((0 + 1)^{*}0\):
</p>

<div>
\begin{array}{l}
  (\{A\},\{0,1\},A \leftarrow 0A\,/\,1A\,/\,0, A)
\end{array}

</div></li>

<li>Lembre-se: \(\Pi(e_{1}\,e_{2},G_{k})=\Pi(e_{1},\Pi(e_2,G_{k}))\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org7790e75">
<h2 id="org7790e75">Correção</h2>
<ul>
<li>A função \(\Pi\) produz PEGs equivalentes a expressões regulares não problemáticas.
<ul>
<li>Dizemos que uma expressão é problemática se ela possui alguma subexpressão da
forma \(e^*\), em que \(\lambda\in[\![e]\!]\).</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org1ea51c2">
<h2 id="org1ea51c2">Correção</h2>
<ul>
<li>Porém, é possível obter expressões não problemáticas equivalentes a uma dada
expressão problemática.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgdbe60a7">
<h2 id="orgdbe60a7">Correção</h2>
<ul>
<li>Vamos apresentar uma transformação que rescreve expressões da forma
\(e^*\), em que \(\lambda \in[\![e]\!]\), produzindo \(e'^*\) tal que
\(\lambda\not\in[\![e']\!]\) e \([\![e^*]\!] = [\![e'^*]\!]\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org1892729">
<h2 id="org1892729">Correção</h2>
<ul>
<li>Para isso, vamos precisar de algumas definições auxiliares.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org455f36f">
<h2 id="org455f36f">Correção</h2>
<ul>
<li>Função \(empty(e)\): decide se \([\![e]\!] = \{\lambda\}\).</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">empty</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">RE</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>
<span style="color: #c678dd;">empty</span> <span style="color: #ECBE7B;">Lambda</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">True</span>
<span style="color: #c678dd;">empty</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">False</span>
<span style="color: #c678dd;">empty</span> (e1 <span style="color: #ECBE7B;">:@:</span> e2) <span style="color: #dcaeea;">=</span> empty e1 <span style="color: #dcaeea;">&amp;&amp;</span> empty e2
<span style="color: #c678dd;">empty</span> (e1 <span style="color: #ECBE7B;">:+:</span> e2) <span style="color: #dcaeea;">=</span> empty e1 <span style="color: #dcaeea;">&amp;&amp;</span> empty e2
<span style="color: #c678dd;">empty</span> (<span style="color: #ECBE7B;">Star</span> e) <span style="color: #dcaeea;">=</span> empty e
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orgbc88a9f">
<h2 id="orgbc88a9f">Correção</h2>
<ul>
<li>Função \(null(e)\): decide se \(\lambda\in [\![e]\!]\).</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">null</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">RE</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>
<span style="color: #c678dd;">null</span> <span style="color: #ECBE7B;">Lambda</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">True</span>
<span style="color: #c678dd;">null</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">False</span>
<span style="color: #c678dd;">null</span> (e1 <span style="color: #ECBE7B;">:@:</span> e2) <span style="color: #dcaeea;">=</span> null e1 <span style="color: #dcaeea;">&amp;&amp;</span> null e2
<span style="color: #c678dd;">null</span> (e1 <span style="color: #ECBE7B;">:+:</span> e2) <span style="color: #dcaeea;">=</span> null e1 <span style="color: #dcaeea;">||</span> null e2
<span style="color: #c678dd;">null</span> (<span style="color: #ECBE7B;">Star</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">True</span>
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orgaed6c85">
<h2 id="orgaed6c85">Correção</h2>
<ul>
<li>Para reescrever uma expressão regular problemática serão utilizadas
duas funções: \(fout\) e \(fin\).</li>

<li>A função \(fout\) percorre a estrutura de uma RE até encontrar \(e^*\) em que
\(\lambda\in [\![e]\!]\).
<ul>
<li>Encontrando essa repetição problemática, usa-se a função \(fin\) para reescrevê-la.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org3ffec25">
<h2 id="org3ffec25">Correção</h2>
<ul>
<li>Definição de \(fout\):</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">RE</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">RE</span>
<span style="color: #c678dd;">fout</span> (e1 <span style="color: #ECBE7B;">:@:</span> e2) <span style="color: #dcaeea;">=</span> (fout e1) <span style="color: #ECBE7B;">:@:</span> (fout e2)
<span style="color: #c678dd;">fout</span> (e1 <span style="color: #ECBE7B;">:+:</span> e2) <span style="color: #dcaeea;">=</span> (fout e1) <span style="color: #ECBE7B;">:@:</span> (fout e1)
<span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> e)
  <span style="color: #dcaeea;">|</span> not (null e) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Star</span> (fout e)
  <span style="color: #dcaeea;">|</span> empty e <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Lambda</span>
  <span style="color: #dcaeea;">|</span> otherwise <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Star</span> (fin e)
<span style="color: #c678dd;">fout</span> e <span style="color: #dcaeea;">=</span> e
</pre>
</div>

</section>
</section>
<section>
<section id="slide-orgd52efa9">
<h2 id="orgd52efa9">Correção</h2>
<ul>
<li>Definição de \(fin\):</li>

</ul>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fin</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">RE</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">RE</span>
<span style="color: #c678dd;">fin</span> (e1 <span style="color: #ECBE7B;">:@:</span> e2) <span style="color: #dcaeea;">=</span> fin (e1 <span style="color: #ECBE7B;">:+:</span> e2)
<span style="color: #c678dd;">fin</span> (<span style="color: #ECBE7B;">Star</span> e)
  <span style="color: #dcaeea;">|</span> null e    <span style="color: #dcaeea;">=</span> fin e
  <span style="color: #dcaeea;">|</span> otherwise <span style="color: #dcaeea;">=</span> fout e
<span style="color: #c678dd;">fin</span> (e1 <span style="color: #ECBE7B;">:+:</span> e2)
  <span style="color: #dcaeea;">|</span> empty e1 <span style="color: #dcaeea;">&amp;&amp;</span> null e2             <span style="color: #dcaeea;">=</span> fin e2
  <span style="color: #dcaeea;">|</span> empty e1 <span style="color: #dcaeea;">&amp;&amp;</span> not (null e2)       <span style="color: #dcaeea;">=</span> fout e2
  <span style="color: #dcaeea;">|</span> null e1 <span style="color: #dcaeea;">&amp;&amp;</span> empty e2             <span style="color: #dcaeea;">=</span> fin e1
  <span style="color: #dcaeea;">|</span> not (null e1) <span style="color: #dcaeea;">&amp;&amp;</span> empty e2       <span style="color: #dcaeea;">=</span> fout e1
  <span style="color: #dcaeea;">|</span> not (null e1) <span style="color: #dcaeea;">&amp;&amp;</span> not (empty e2) <span style="color: #dcaeea;">=</span> fout e1 <span style="color: #ECBE7B;">:+:</span> fin e2
  <span style="color: #dcaeea;">|</span> not (empty e1) <span style="color: #dcaeea;">&amp;&amp;</span> not (null e2) <span style="color: #dcaeea;">=</span> fin e1 <span style="color: #ECBE7B;">:+:</span> fout e2
  <span style="color: #dcaeea;">|</span> otherwise                       <span style="color: #dcaeea;">=</span> fin e1 <span style="color: #ECBE7B;">:+:</span> fin e2
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org8e94a68">
<h2 id="org8e94a68">Exemplo</h2>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
</pre>
</div>


</section>
</section>
<section>
<section id="slide-orgb2c2653">
<h2 id="orgb2c2653">Exemplo</h2>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
</pre>
</div>


</section>
</section>
<section>
<section id="slide-orga360ecc">
<h2 id="orga360ecc">Exemplo</h2>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
</pre>
</div>


</section>
</section>
<section>
<section id="slide-org2cb6fcd">
<h2 id="org2cb6fcd">Exemplo</h2>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> fin (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))) <span style="color: #dcaeea;">=</span>
</pre>
</div>


</section>
</section>
<section>
<section id="slide-orgeb97590">
<h2 id="orgeb97590">Exemplo</h2>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> fin (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fout (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span>) <span style="color: #ECBE7B;">:+:</span> fout (<span style="color: #ECBE7B;">Char</span> <span style="color: #98be65;">'b'</span>)) <span style="color: #dcaeea;">=</span>
</pre>
</div>


</section>
</section>
<section>
<section id="slide-org0cdf146">
<h2 id="org0cdf146">Exemplo</h2>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #c678dd;">fout</span> (<span style="color: #ECBE7B;">Star</span> (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:@:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (((<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fin (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Lambda</span>) <span style="color: #ECBE7B;">:+:</span> fin (<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>))) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (fout (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span>) <span style="color: #ECBE7B;">:+:</span> fout (<span style="color: #ECBE7B;">Char</span> <span style="color: #98be65;">'b'</span>)) <span style="color: #dcaeea;">=</span>
<span style="color: #ECBE7B;">Star</span> (<span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'a'</span> <span style="color: #ECBE7B;">:+:</span> <span style="color: #ECBE7B;">Chr</span> <span style="color: #98be65;">'b'</span>)
</pre>
</div>

</section>
</section>
<section>
<section id="slide-org1296e0b">
<h2 id="org1296e0b">Concluindo</h2>
<ul>
<li>A função \(\Pi\) permite a conversão de expressões regulares em PEGs.
<ul>
<li>Como PEGs são determinísticas, o casamento de padrão torna-se previsível,
ao contrário de RE que depende da implementação.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org807aa01">
<h2 id="org807aa01">Concluindo</h2>
<ul>
<li>Expressões problemáticas podem ser convertidas em expressões equivalentes
eliminando dificuldades para correção da conversão em PEGs.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org878e2f0">
<h2 id="org878e2f0">Exercícios</h2>
<ul>
<li>Implemente a conversão de expressões regulares em PEGs equivalentes e
obtenha um interpretador para expressões regulares utilizando o intepretador de PEG
construído por você na atividade da Aula 14.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orge98f545">
<h2 id="orge98f545">Referências</h2>
<ul>
<li>Medeiros, Sérgio; Mascarenhas, Fábio; Ierusalimschy, Roberto.
From Regular Expressions to Parsing Expression Grammars.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/dist/reveal.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/markdown/markdown.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/notes/notes.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/search/search.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1200,
height: 800,
margin: 0.20,
minScale: 0.50,
maxScale: 2.50,

transition: 'none',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
