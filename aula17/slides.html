<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Parsing Machines para PEGs</title>
<meta name="author" content="Rodrigo Ribeiro"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/dist/reveal.css"/>

<link rel="stylesheet" href="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/dist/theme/white.css" id="theme"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1>Parsing Machines para PEGs</h1><h2>PCC102 - Teoria da computação</h2><h3> Rodrigo Ribeiro</h3>
</section>

<section>
<section id="slide-orgbc2406a">
<h2 id="orgbc2406a">Objetivos</h2>
<ul>
<li>Apresentar uma semântica alternativa para PEGs usando uma máquina virtual.</li>

<li>Apresentar como PEGs podem ser compiladas para programas desta máquina virtual.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orga934eaf">
<h2 id="orga934eaf">Motivação</h2>
<ul>
<li>Ferramentas de processamento de texto utilizam expressões regulares (REGEX)
para tarefas de casamento de padrão.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org9492694">
<h2 id="org9492694">Motivação</h2>
<ul>
<li>Porém, expressões regulares possuem problemas de ambiguidade que tornam o seu
resultado dependente da implementação utilizada.</li>

<li>Solução: PEGs são determinísticas e podem expressar os mesmos padrões que
expressões regulares.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5af9fb5">
<h2 id="org5af9fb5">Motivação</h2>
<ul>
<li>Algoritmos para parsing baseados em PEGs possuem tempo linear, no pior caso, sobre o
tamanho da entrada.</li>

<li>Porém, o tempo linear é usando memoização, o que demanda espaço linear sobre o tamanho
da entrada</li>

</ul>

</section>
</section>
<section>
<section id="slide-orga1664db">
<h2 id="orga1664db">Motivação</h2>
<ul>
<li>Pode-se melhorar a complexidade de espaço para processamento de texto usando PEGs?
<ul>
<li>Espaço é um problema para grandes quantidades de texto.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6a4d7b7">
<h2 id="org6a4d7b7">Motivação</h2>
<ul>
<li>Sim! Para isso, Medeiros e Ierusalimschy definem uma máquina virtual que é capaz de
modelar PEGs como programas a serem executados.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf645e58">
<h2 id="orgf645e58">Parsing Machine</h2>
<ul>
<li>A máquina virtual possui as instruções para processamento de texto.</li>

<li>PEGs são compiladas para programas sobre essa máquina virtual</li>

</ul>

</section>
</section>
<section>
<section id="slide-org6a810ac">
<h2 id="org6a810ac">Parsing Machine</h2>
<ul>
<li>Sintaxe:

<ul>
<li>Chr c: Tenta casar o caractere c com a posição atual da entrada, movendo em
uma posição do texto em caso de sucesso.</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org4521454">
<h2 id="org4521454">Parsing Machine</h2>
<ul>
<li>Sintaxe:

<ul>
<li>Any: Casa qualquer caractere e avança uma posição do texto.</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org55503a5">
<h2 id="org55503a5">Parsing Machine</h2>
<ul>
<li>Sintaxe:
<ul>
<li>Choice l: empilha o deslocamento l que é usado para backtracking da máquina.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org04d54a8">
<h2 id="org04d54a8">Parsing Machine</h2>
<ul>
<li>Sintaxe:

<ul>
<li>Call l: empilha o endereço da próxima instrução e salta para a instrução no
deslocamento l</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org8a9e072">
<h2 id="org8a9e072">Parsing Machine</h2>
<ul>
<li>Sintaxe

<ul>
<li>Jump l: Modifica o contador de instrução usando o deslocamento l.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6dd7379">
<h2 id="org6dd7379">Parsing Machine</h2>
<ul>
<li>Sintaxe:
<ul>
<li>Return: Desempilha um endereço da pilha e modifica o contador de instruções
para esse endereço</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org81e93e9">
<h2 id="org81e93e9">Parsing Machine</h2>
<ul>
<li>Sintaxe:
<ul>
<li>Commit l: Desempilha uma entrada da pilha para backtracking e usa l como deslocamento do
contador de instruções</li>

</ul></li>

</ul>


</section>
</section>
<section>
<section id="slide-org992b7f9">
<h2 id="org992b7f9">Parsing Machine</h2>
<ul>
<li>Sintaxe:
<ul>
<li>Fail: Força uma falha na execução da máquina</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org23a05c6">
<h2 id="org23a05c6">Parsing Machine</h2>
<ul>
<li>Semântica operacional da máquina é expressa como uma relação entre configurações.</li>

<li>Uma configuração é formada por uma tripla ou uma indicação de falha</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd737d7b">
<h2 id="orgd737d7b">Parsing Machine</h2>
<ul>
<li>Triplas são compostas por:

<ul>
<li>Contador de instrução</li>

<li>Posição atual no texto de entrada</li>

<li>Pilha.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgdb3c242">
<h2 id="orgdb3c242">Parsing Machine</h2>
<ul>
<li>Pilhas são compostas por entradas da forma \(\mathbb{N}\cup\mathbb{N}\times \mathbb{N}\).
<ul>
<li>Entradas \(\mathbb{N}\) são endereços de retorno.</li>
<li>Entradas \(\mathbb{N}\times\mathbb{N}\) são entradas para backtracking.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb9043ea">
<h2 id="orgb9043ea">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Chr</li>

</ul>

<div>
\begin{array}{l}
\langle pc,i,s \rangle \to \langle pc + 1, i + 1, e\rangle\text{ se }T[i] = c\\
\\
\text{em que }P[pc] = Chr\,c
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orga1635ff">
<h2 id="orga1635ff">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Chr</li>

</ul>

<div>
\begin{array}{l}
\langle pc,i,s \rangle \to Fail(s)\text{ se }T[i] = c'\\
\\
\text{em que }P[pc] = Chr\,c \text{ e } c\neq c'
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orgae6ccaf">
<h2 id="orgae6ccaf">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Any</li>

</ul>

<div>
\begin{array}{l}
\langle pc,i,s \rangle \to \langle pc + 1, i + 1, e\rangle\text{ se }i + 1\leq |T|\\
\\
\text{em que }P[pc] = Any
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orgf99923d">
<h2 id="orgf99923d">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Any</li>

</ul>

<div>
\begin{array}{l}
\langle pc,i,s \rangle \to Fail(e)\text{ se }|T| \leq i + 1\\
\\
\text{em que }P[pc] = Any
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org86af784">
<h2 id="org86af784">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Choice l</li>

</ul>

<div>
\begin{array}{l}
\langle pc,i,s \rangle \to \langle pc + 1, i, (pc + l, i) : e\rangle\\
\\
\text{em que }P[pc] = Choice\:l
\end{array}

</div>


</section>
</section>
<section>
<section id="slide-orgbebe470">
<h2 id="orgbebe470">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Call l</li>

</ul>

<div>
\begin{array}{l}
\langle pc,i,s \rangle \to \langle pc + l, i, (pc + 1, i) : e\rangle\\
\\
\text{em que }P[pc] = Call\:l
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org8aaceb4">
<h2 id="org8aaceb4">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Return</li>

</ul>

<div>
\begin{array}{l}
\langle pc_{0},i, pc_{1} : s \rangle \to \langle pc_{1}, i, e\rangle\\
\\
\text{em que }P[pc] = Return
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orgbdcfee4">
<h2 id="orgbdcfee4">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Commit l</li>

</ul>

<div>
\begin{array}{l}
\langle pc, i, h:s\rangle \to \langle pc + l, i, e\rangle\\
\\
\text{em que }P[pc] = Commit\:l
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org680af22">
<h2 id="org680af22">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Fail</li>

</ul>

<div>
\begin{array}{l}
\langle pc, i, s\rangle \to Fail(s)\\
\\
\text{em que }P[pc] = Fail
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org7c14b12">
<h2 id="org7c14b12">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Fail</li>

</ul>

<div>
\begin{array}{l}
Fail(pc : e) \to Fail(e)
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orga4a520b">
<h2 id="orga4a520b">Parsing Machine</h2>
<ul>
<li>Semântica para instrução Fail</li>

</ul>

<div>
\begin{array}{l}
Fail((pc, i) : e) \to \langle pc , i , e \rangle
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org82bd250">
<h2 id="org82bd250">Compilando Parsing Expressions</h2>
<ul>
<li>Agora, vamos mostrar como compilar PEGs em programas da máquina virtual apresentada.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org2a0d8ec">
<h2 id="org2a0d8ec">Compilando Parsing Expressions</h2>
<ul>
<li>O processo de compilar PEGs é definido usando uma função \(\Pi\) que, a partir de uma
parsing expression, produz um programa para máquina virtual apresentada.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org27849c3">
<h2 id="org27849c3">Compilando Parsing Expressions</h2>
<ul>
<li>Compilando a parsing expression \(a \in \Sigma\):</li>

</ul>

<div>
\begin{array}{l}
  \Pi(a) = Chr\:a
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org3977acf">
<h2 id="org3977acf">Compilando Parsing Expressions</h2>
<ul>
<li>Compilando a parsing expression \(e_1\,e_2\):</li>

</ul>

<div>
\begin{array}{l}
  \Pi(e_1\,e_2) = \Pi(e_1)\,\Pi(e_2)
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org38cec7e">
<h2 id="org38cec7e">Compilando Parsing Expressions</h2>
<ul>
<li>Compilando a parsing expression \(e_1\,/\,e_2\):</li>

</ul>

<div>
\begin{array}{lcl}
  \Pi(e_1\,/\,e_2) & = & Choice\,|\Pi(e_1)| + 2\\
                   &   & \Pi(e_1)\\
                   &   & Commit\,|\Pi(e_2)| + 1\\
                   &   & \Pi(e_2)\\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-org6b04ce9">
<h2 id="org6b04ce9">Compilando Parsing Expressions</h2>
<ul>
<li>Compilando a parsing expression \(!\,e\):</li>

</ul>

<div>
\begin{array}{lcl}
  \Pi(!\,e) & = & Choice\,|\Pi(e)| + 3\\
            &   & \Pi(e)\\
            &   & Commit\,1\\
            &   & Fail\\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orgc8ec9d7">
<h2 id="orgc8ec9d7">Compilando Parsing Expressions</h2>
<ul>
<li>Compilando a parsing expression \(e^*\):</li>

</ul>

<div>
\begin{array}{lcl}
  \Pi(e^*) & = & Choice\,|\Pi(e)| + 2\\
           &   & \Pi(e)\\
           &   & Commit\,-(|\Pi(e)| + 1)\\
\end{array}

</div>

</section>
</section>
<section>
<section id="slide-orge3d5a3a">
<h2 id="orge3d5a3a">Exercícios</h2>
<ul>
<li>Apresente uma prova detalhada do seguinte teorema.</li>

<li>Se \(G[p]ss'\leadsto_{PEG} s'\) então \(G[p]ss' \leadsto s'\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0280ed8">
<h2 id="org0280ed8">Referências</h2>
<ul>
<li>Mascarenhas, Fábio; Medeiros, Sérgio; Ierusalimschy, Roberto.
On the relation between context-free grammars and parsing expression grammars.
Science of computer programming.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/dist/reveal.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/markdown/markdown.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/notes/notes.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/search/search.js"></script>
<script src="/Users/rodrigo/.emacs.d/.local/straight/build-27.2/revealjs/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1200,
height: 800,
margin: 0.20,
minScale: 0.50,
maxScale: 2.50,

transition: 'none',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
